# 更复杂的插件开发场景

- 插件中如何获取传递的参数

  - 通过插件的构造函数进行获取

    ```js
    module.exports = class MyPlugin{
        constructor(options) {
            this.options = options;
        }
        apply() {
            console.log('apply', this.options);
        }
    }
    ```

- 插件的错误处理

  - 参数校验阶段可以直接throw的方式抛出

    ```js
    throw new Error('error message');
    ```

  - 通过compilation对象的warnings和error接收

    ```js
    conpilation.warings.push('warning');
    conpilation.errors.push('error')
    ```

- 通过Compilation进行文件写入

  - Complation上的assets可以用于文件写入

    - 可以将zip资源包设置到compilation.assets对象上

  - 文件写入需要使用webpack-source

    ```js
    const { RawSource } = require('webpack-sources');
    module.exports  clcass DemoPlugin{
        constructor(options) {
            this.options = options;
        }
        apply(compiler) {
            const { name } = this.options;
            compiler.hooks('emit', (compilation, cb) => {
                compilation.assets[name] = new RawSource('demo');
                cb();
            })
        }
    }
    ```

- 插件扩展：编写插件的插件

  - 插件自身也可以通过暴露hooks的方式进行自身扩展，以html-webpack-plugin为例：
    - html-webpack-plugin-alter-chunks(Sync)
    - html-webpack-plugin-before-html-generation(Async)
    - html-webpack-plugin-alter-asset-tags(Async)
    - html-webpack-plugin-after-html-processing(Async)
    - html-webpack-plugin-after-emit(Async)