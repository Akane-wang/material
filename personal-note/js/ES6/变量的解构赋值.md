# 数组的解构赋值

## 基本用法

- 完全解构
  - 解构不成功，值就会等于undefined
- 不完全解构
  - 等号左边的模式，只匹配一部分的等号右边的数组
- 等号的右边不是数组（或者不是可遍历的结构），则将会报错
- set结构，也可以使用数组的解构赋值
  ```js 
   let [x,y,z] = new Set(['a','b','c'])
  ```
- 只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值

## 默认值

- ES6内部使用严格相等运算符（===），判断一个位置是否有值，所以当一个数组成员严格等于undefined，默认值才会生效。
  - 以下代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined
 ```js
 let [foo = true] = []; // foo=> true
 let [x,y='b'] = ['a']; // x = 'a',y = 'b'
 let [x,y = 'b'] = ['a'.undefined] // x='a',y = 'b'
 ```
- 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值
 ```js
  function f() {
      console.log('aaa');
  }

  let [x = f()] = [1]; // x能取到值，所以函数f根本不会执行

  // 上面代码等于下面代码
  let x;
  if([1][0] === undefined) {
      x = f();
  }else {
      x = [1][0];
  }
 ```
- 默认值可以引用解构赋值的其他变量，但是该变量必须已经声明
 ```js
  let [x =1, y = x] = []; // x= 1;y =1
  let [x=1, y = x] [2]; // x = 2,y =2
  let [x = 1, y =x] = [1,2] // x = 1,y =2
  let [x =y, y = 1] = []; // RefrenceError
 ```

# 对象的解构赋值

## 简介

- 对象与数组的不同：
  - 数组的元素时按次序排列的，变量的取值由它的位置决定
  - 对象的属性没有次序，变量必须与属性同名，才能取到正确的值
- 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量，真正被赋值的是后者，不是前者
  ```js
   let {foo:baz} = {foo: 'aaa',bar: 'bbb'}; // baz: 'aaa', foo: error,not defined
  ```
- 对象的解构赋值可以取到继承的属性
  ```js
   const obj1 = {};
   const obj2 = {foo:'bar'};
   Object.setPrototypeOf(obj1,obj2);
   const {foo} = obj1; // foo: "bar"
  ```

## 默认值

## 注意点

- 如果要将一个已经声明的变量用于解构赋值，必须非常小心
  ```js
  // 错误的写法
    let x;
    {x} = {x: 1};
    // SyntaxError: syntax error

  // 正确的写法
    let x;
    ({x} = {x:1}); 
  ```
- 解构赋值允许等号左边的模式之中，不放置任何变量名，因此，可以写出非常古怪的赋值表达式
 ```js
  // 虽然表达式毫无意义，但是语法时合法的，可以执行
  ({} = [true,false]);
  ({} = 'abc');
  ({} = [])
 ```
- 由于数组本质是特殊的对象，因此可以对数组进行对象属性的结构
  ```js
   let arr = [1,2,3];
   let {0:first,[arr.length-1]: last} = arr; // first: 1, last: 3 
  ```
  - 上面代码对数组进行对象解构，这种写法，属于“属性名表达式”

# 字符串的解构赋值

- 字符串也可以解构赋值，因为字符串被转换成一个类似数组的对象
  ```js
   const [a,b,c,d,e] = 'hello'; // a: 'h', b: 'e', c:'l',...
  ```
- 类似数组的对象都有一个length属性，隐藏还可对这个属性解构赋值
  ```js
  let {length: len} = 'hello'; // len: 5
  ```

# 数值和布尔值的解构赋值

- 解构赋值时，如果等号右边是数值和布尔值，会先转为对象
- 解构赋值的规则是：只要等号右边的值不是对象或数组，就先将其转为对象，由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错
  ```js
   let {prop: x} = undefined;
   let {prop: y} null;// x,y: typeError
  ```

# 函数参数的解构赋值

# 圆括号问题

- 只要有可能导致解构的歧义，就不得使用圆括号
  - 这条规则实际上不容易辨别，处理起来很麻烦，所以只要有可能，就不要在模式中放置圆括号

## 不能使用圆括号的情况

- 变量声明语句不能使用圆括号
```js
 let [(a)],{x:(c)},({x:c})...
```
- 函数参数不能使用圆括号
- 赋值语句的模式

## 可以使用圆括号的情况

- 赋值语句的非模式部分

# 用途

- 交换变量的值
- 从函数返回多个值
- 函数参数的定义
- 提取JSON数据
```js
    let jsonData = {
    id: 42,
    status: "OK",
    data: [867, 5309]
    };

    let { id, status, data: number } = jsonData;

    console.log(id, status, number);
    // 42, "OK", [867, 5309]
```
- 函数参数的默认值
- 遍历Map结构
  - 任何部署了迭代器接口的对象，都可以用for...of循环遍历。
  ```js
    const map = new Map();
    map.set('first', 'hello');
    map.set('second', 'world');

    for (let [key, value] of map) {
    console.log(key + " is " + value);
    }
    // first is hello
    // second is world
  ```
- 输入模块的指定方法
  ```js
  const { SourceMapConsumer, SourceNode } = require("source-map");
  ```
