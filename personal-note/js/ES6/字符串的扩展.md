# 字符的Unicode表示法

- ES6加强了对Unicode的支持，允许采用`\uxxxx`形式表示一个字符，其中`xxxx`表示字符的Unicode码点，这种表示法只限于码点在`\u0000`~`\uFFFF`之间的字符，超出这个范围，必须用两个双字节的形式表示
- ES6改进原码点超过`\u0xFFFF`无法正确理解的问题，将码点放入大括号，就能正确解读该字符
  - `'\u{1F680}'==='\uD83D\uDE80'`

# 字符串的遍历器接口

- ES6为字符串添加了遍历器接口，使得字符串可以被`for...of`循环遍历
- 这个遍历器的最大优点是：可以识别大于`\0xFFFF的码点，传统的for循环无法识别这样的码点

# 直接输入U+2028和U+2029

- JavaScript规定有5个字符，不能在字符串里面直接使用，只能使用转义形式
  - U+005C： 反斜杠
  - U+000D： 回车
  - U+2028: 行分隔符
  - U+2029：段分隔符
  - U+000A：换行符
- 在JSON格式中允许字符串里面直接使用U+2028和U+2029，这样一来，服务器输出的JSON被JSON.parse解析，就有可能直接报错
  - ES2019允许JavaScript字符串直接输入U+2028和U+2029
  - 模板字符串现在就允许直接输入这两个字符
  - 正则表达式依然不允许直接输入这两个字符
  - JSON不允许直接包含正则表达式

# JSON.stringify()的改造

- ES2019改变了JSON.stringify()的行为，如果遇到`0xD800`到`0xDFFF`之间的单个码点，或者不存在配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。

# 模板字符串

- `(反引号)xxxx${}(反引号)`
  - 模板字符串是增强版的字符串，用反引号（`）标识
  - 可以当做普通字符串使用
  - 可以用来定义多行字符串
    - 所有的空格和缩进都会被保留在输出之中
    - 如换行被保留时，如果不想使用换行，可以使用`trim`方法消除它
  - 可以用来在字符串中嵌入变量
    - 将变量名写在`${}`中
    - 大括号内可以放任意的JavaScript表达式，可以进行运算，以及引用对象属性，调用函数等
    - 大括号中的值不是字符串时，按照一般方法的规则转为字符串
    - 大括号内是字符串时会被原样输出
    - 模板字符串可以嵌套
        ```js
         const tmpl = addrs => `
            <table>
             ${addrs.map(addr => `
               <tr><td>${addr.first}</td></tr>
               <tr><td>${addr.last}</td></tr>
               `).join('')}
            </table>
         `;
        ```
    - 如果需要引用模板字符串本身，在需要时执行，可以写成函数

# 实例：模板编译
```js

    let template = `
        <ul>
            <% for(let i = data.supplies.length; i > 0; i--) {%>
                <li><%= data.supplies[i] %></li>
            <% } %>
        </ul>
    `;
```
- 编译这个模板字符串的思路有二：
  - 将其转换为JavaScript表达式字符串
    ```js
     echo('<ul>');
     for(let i = data.supplies.length; i > 0; i--) {
         echo('<li>');
         echo(data.supplies[i-1]);
         echo('</li>');
     };
     echo('</ul>');

    // 使用正则表达式
     let evalExpr = /<%=.+?%>/g;
     let expr = /<%([\s\S]+?)%>/g;
     template = template.replace(evalExpr,'`); echo($1); \n echo(`').replace(expr,'`); \n $1 \n echo(`');
     template = 'echo(`') + template + '`);';

    // 将template封装在一个函数里返回
    let script = `function parse(data){
        let output = "";
        function echo(html) {
            output+=html;
        }
        ${template}
        return output;
    })`;
    return script;

    // 将上面的内容拼装成一个模板编译函数 compile
    function compile(template){
    const evalExpr = /<%=(.+?)%>/g;
    const expr = /<%([\s\S]+?)%>/g;

    template = template
        .replace(evalExpr, '`); \n  echo( $1 ); \n  echo(`')
        .replace(expr, '`); \n $1 \n  echo(`');

    template = 'echo(`' + template + '`);';

    let script =
    `(function parse(data){
        let output = "";

        function echo(html){
        output += html;
        }

        ${ template }

        return output;
    })`;

    return script;
    }

    // compile 函数的用法如下：
    let parse = eval(compile(template));
    div.innerHTML = parse({ supplies: [ "broom", "mop", "cleaner" ] });
    ```

# 标签模板

- 模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串，这杯成为“标签模板”功能
  ```js
  alert`hello`
  // 等同于
  alert(['hello'])
  ```
- 标签模板不是模板，是函数调用的一种特殊形式，标签指的是函数，紧跟在后面的模板字符串是它的参数
- 当模板字符串里有变量，就不是简单的调用，而是会将模板字符串先处理成多个参数，再调用函数
  ```js
   let a = 5, b = 10;
   tag`Hello ${a+b} word ${a*b}`;
   // 等同于
   tag(['hello','world',''],15,50);
  ```
- 函数tag依次会接收到多个参数
  ```js
   function tag(stringArr, value1,value2) {}
   //等同于
   function tag(stringArr, ...values) {}
  ```
- 标签模板的重要应用
  - 过滤HTML字符串，防止用于输入恶意内容。
  - 多语言转换（国际化处理）
  - 可以使用标签模板在JavaScript中嵌入其他语言

# 模板字符串的限制

- 模板字符串默认会将字符串转义，导致无法嵌入其他语言
  - 在标签模板的情况下，ES2018放松了对字符串转义的限制，所以如果无法解析，就会设置为undefined而不是报错。其他场合依然会报错。