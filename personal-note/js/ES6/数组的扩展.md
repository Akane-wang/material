# 扩展运算符
## 含义
- 扩展运算符： `...`,好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列
- 作用：
  - 函数调用
    ```js
     function push(array,...items) {
         array.push(...items);
     }
    ```
  - 可与正常的函数参数结合使用
    ```js
        function f(v,w,x,y,z) { }
        const args = [0,1];
        f(-1, ...args, 2, ...[3]);
    ```
  - 扩展运算符后可放置表达式
    ```js
        const arr = [
            ...(x > 0 ? ['a']:[]),'b',
        ]
    ```
    - 扩展运算符后面是一个空数组，则不产生任何效果
        ```js
            [...[],1]  //  [1]
        ```
  - 只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错

## 替代函数的apply方法

- 扩展运算符可以展开数组，所以不再需要apply方法将数组转为函数的参数了。
    ```js
        // ES5写法
        function f(x,y,z) {
            // ...
        }

        var args = [0,1,2];
        f.apply(null,args);
        // ES6写法
        function f(x,y,z) {
            // ...
        }

        let args = [0,1,2];
        f(...args);
    ```
    - 该方法可用于
      - 求一个数组中的最大值
        ```js
            //ES5
            Math.max.apply(null,[14,3,77])
            // ES6
            Math.max(...[14,3,77]);
            // 都等价于
            Math.max(14,3,77);
        ```
      - 通过push函数将一个数组添加到另一个数组的尾部
        - push的参数不能是数组，所以通过apply方法变通使用push方法处理数组
        ```js
            //ES5
            var arr1 = [0,1,2];
            var arr2 = [3,4,5];
            Array.prototype.push.apply(arr1,arr2);
            //ES6
            let arr1 = [0,1,2];
            let arr2 = [3,4,5];
            arr1.push(...arr2);
        ```

## 扩展运算符的应用

### 复制数组
- 数组是复合的数据类型，直接复制是只复制了指向底层数据结构的指针，而不是克隆一个全新的数组,更改数组2会对数组1产生影响
  - ES5
    - `const a2 = a1.concat();`
  - ES6(a2是a1的克隆)
    - `const a2 = [...a1];`或者`const [...a2] = a1`;

### 合并数组
- 有数组 `const arr1 = [1,2,3]; const arr2 = [4,5,6]; const arr3 = [7,8,9];`
- ES5
  - `arr1.concat(arr2,arr3)`;
- ES6
  - `[...arr1,...arr2,...arr3]`;

# Array.of()
- 将一组值，转换为数组
  - 用于弥补数组构造函数Array()的不足
    - Array()无参数、有一个参数、三个参数时，返回结果不一样，只有当参数个数不小于2时，才会返回由参数组成的新数组，参数个数只有一个时，实际是指定数组的长度
        ```js
            Array() //[]
            Array(3) // [, , ,]
            Array(3,2,16) //[3,2,16]
        ```
    - Array.of用于代替Array/new Array(),不存在由于参数不同而导致的重载，行为非常统一
    - 总是返回参数值组成的数组，如果无参数，则返回空数组
  - 实现
    ```js
        function Arrayof() {
            return [].slice.call(arguments); 
        }
    ```
# 数组实例的copyWithin()
- copyWithin()，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），返回当前数组
- `Array.prototype.copyWithin(target, start = 0, end = this.length)`接受三个参数
  - target(必须)： 从该位置开始替换数据，如果为负，则表示倒数
  - start(可选)：从该位置开始读取数据，默认为0，为负则从末尾开始计算
  - end(可选)：到该位置`前`停止读取数据，默认等于数组长度，为负则从末尾开始计算

# 数组实例find()和findIndex()
- find()
  - 用于找出第一个符合条件的数组成员，参数是一个回调函数
  - 所有参数成员依次执行回调函数，直到找出第一个返回值为true的成员，然后返回该成员，找不到就返回undefined
  - 回调函数可以接受三个参数，依次是当前的值，当前的值的位置，原数组
- findIndex()
  - 用于返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1
- find(),findIndex()可接受第二个参数，用于绑定回调函数的this对象
- 可用于发现NaN，弥补indexOf的不足
    ```js
    [NaN].indexOf(NaN) // -1
    [NaN].findIndex(y => Object.is(NaN,y)) // 0
    ```

# 数组实例的fill()
- fill 方法使用一个给定值，填充一个数组
  - 数组中的已有元素会被全部抹去，用填充值填充整个数组
  - 可应用于空数组的初始化
    ```js
    ['a','b','c'].fill(7) // [7,7,7]
    new Array(3).fill(7) // [7,7,7]
    ```
- 可接受第二个和第三个参数，用于指定填充的起始位置和结束位置
  - 从1号位开始，向原数组填充7，到2号位结束
    ```js
        ['a','b','c'].fill(7,1,2) // ['a',7,'c']
    ```
  - 如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象

# 数组实例的entries(),keys(),values()
- 用于遍历数组，返回一个遍历对象，可以用for...of循环进行遍历
- 区别
  - keys(): 对键名进行遍历
  - values():对键值进行遍历
  - entries(): 对键值对进行遍历
- 如果不使用for...of循环，可以手动调用遍历器对象的next()方法，进行遍历
```js
    // for...of
    for(let index/indexValue/value of [].keys/entries/values()) {
        console.log(index/indexValue/value)
    }
    // next
    [1,2,3].entries().next().value
```
# 数组实例的includes()
- Array.prototype.includes返回一个布尔值，表示某个数组是否包含给定的值
- [].includes(target,startSearch=0`(为负数时表示倒数的位置，如果负数绝对值大于length,则重置为0)`)
  - includes前：
    - 我们使用indexOf()
      - 缺点：
        - 不够语义化，其含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观
        - 内部使用严格相等运算符（===）进行判断，导致对NaN的误判`[NaN].indexOf(NaN)为-1`
  - includes后
    - [NaN].includes(NaN)为true
- Map和Set数据结构有一个has方法，需要注意与includes区分
  - Map的has方法：
    - 用于查找键名
      - Map.prototype.has(key)
      - weakMap.prototype.has(key)
      - Reflect.has(target,propertyKey)
  - Set的has方法
    - 用于查找值
      - Set.prototype.has(value)
      - WeakSet.prototype.has(value)

# 数组实例的flat(),flatMap()

- flat()
  - 应用场景
    - 数组的成员还是数组时，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维数组，该方法返回一个新数组，对原数据没有影响
    - flat()默认只会拉平一层，如果想要拉平多层的嵌套数组，可以将flat方法参数写成一个整数，表示想要拉平的层数，默认为1
    - 无论多少层嵌套，都要转为一维数组，可以用Infinity关键字作为参数：[[[]],[]].flat( /intNum/'Infinity') => []
    - 如果原数组有空位，flat方法会跳过空位:[1,2,,3].flat()=>[1,2,3]
- flatMap()
  - 对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat方法，该方法返回一个新数组，不改变原数组
    ```js
        [2,3,4].flatMap(x=>[x,x*2])
        // [2,4,3,6,4,8]
        //相当于
        [[2,4],[3,6],[4,8]].flat()
    ```
  - 只能展开一层数组
    ```js
        [1,2,3,4].flatMap(x => [[x*2]])
        /* 相当于 */
        [[[2]],[[4]],[[6]],[[8]]].flat()
        //[[2],[4],[6],[8]]
    ```
  - flatMap()的方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员，当前数组成员的位置（从零开始），原数组，还可以有第二个参数，用于绑定遍历函数里面的this
    - arr.flatMap(function callback(currentValue[,index[,array]]){},thisArg)

# 数组的空位

- 数组的空位： 数组的某一个位置没有任何值，比如Array构造函数返回的数组都是空位 `Array(3) => [,,,]`
  - 空位不是undefined，一个位置的值等于undefined依然是有值的，空位无任何值
    ```js
     0 in [undefined,undefined,undefined] // true,表示该数组的0号位置是有值的
     0 in [,,,] // false 表示该数组无值
    ```
- ES5对空位的处理
  - 会跳过空位
    - forEach()
    - filter()
    - reduce()
    - every()
    - some()
  - 跳过空位但保留这个值
    - map()
  - 将空位视为undefined，而undefined和null会被处理成空字符串
    - join()
    - toString()
- ES6则是明确将空位转为undefined
  - Array.from
  - 扩展运算符(...)
  - copyWithin：连空位一起拷贝
  - fill(): 将空位视为正常的数组位置
  - for...of循环：会遍历空位
  - entries()
  - keys()
  - values()
  - find()
  - findIndex()

# Array.prototype.sort()的排序稳定性

- 排序稳定性： 是排序算法的重要属性，指的是排序关键字相同的项目，排序前后的顺序不变
- 排序
  - 稳定排序
    - 插入排序
    - 合并排序
    - 冒泡排序
  - 不稳定排序
    - 堆排序
    - 快速排序
- 不稳定排序的主要缺点：
  - 多重排序时可能会产生问题
- Array.prototype.sort()的默认排序算法在ES2019明确规定必须稳定