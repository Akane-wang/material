# 章六、数值的拓展
## 二进制和八进制表示法
- 二进制和八进制的新写法
  - 二进制：0B/0b
  - 八进制：0o/0O
  - 要转为十进制，使用Number方法
  ```js
  Number('0b111') // 7
  Number('0o10') // 8
  ```

## Number方法拓展

## Math对象的拓展

# 章七、函数的扩展
## 函数参数的默认值
### 基本用法
- 为函数指定默认值
5:
function log (x,y) {
  y = y || 'worked';
  console.log(x,y);
} 
log('hello');
log('hello','work');
log('hello','')

### 与解构赋值默认值结合使用
- 参数默认值可以与解构赋值的默认值结合使用。

### 参数默认值的位置
- 默认值的参数应该是函数的尾参数
- 如果非尾部的参数设置默认值，实际上这个参数是无法省略的。
- 使用undefined可以触发默认参数，因为在内部使用的是===判断，必须传入的参数是undefined才能触发默认参数，null则无法触发。因为null!==undefined
function f(x=1,y) {
  return [x,y];
}
f(undefined,1) // 需要用undefined占位，才能正确使用非尾部默认参数的函数

### 函数的length属性
- 指定了默认值以后，函数的length属性将返回没有指定默认值的参数个数。即，指定了默认值以后，length属性将会失真。
  - 因为length属性的含义是该函数预期传入的参数个数，某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，rest参数也不会计入length属性
  - 如果设置了默认值的参数不是为参数，那么length属性也不再计入后面的参数。
### 作用域
- 一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域，等到初始化结束，这个作用域就会消失，这种语法行为在不设置参数默认值时是不会出现的。
### 应用
- 利用参数默认值可以指定某一个参数不得省略，如果省略就要抛出一个错误。
  - 参数的默认值不是在定义时执行，而是在运行时执行，如果参数已经赋值，默认值中的函数就不会运行
  - 可以将参数默认值设置为undefined，表明这个参数是可以省略的。
  ```js
  function throwIfMissing() {
    throw new Error('Missing parameter');
  }

  function foo(mustBeProvided = throwIfMissing()) {
    return mustBeProvided;
  }

  foo()
  ```
## rest参数
- rest参数：形如[...变量名],用于获取函数的多余参数，以解放arguments对象（可以不用arguments对象了）。
- rest参数搭配的变量是一个数组，该变量将多余的参数放入其中。
- rest参数之后不能再有其他参数，否则会报错（只能是最后一个参数）
- 函数的length属性不包括rest参数。

```js
function add(...values) { // value 是一个数组，所有数组特有的方法都可以用于这个变量。
  let sum = 0;
  for(let val of values) {
    sum+=val;
  }
  return sum;
}
add(2,5,3);
add.length // 0
```
## 严格模式
- ES5开始，函数内部可以设定为严格模式
```js
function foo() {
  'use strict';
  // code...
}
```
- ES6规定，只要函数参数使用了默认值、解构赋值、或者扩展运算符，则函数内部就不能显示设定为严格模式，否则会报错
  - 原因：函数内部的严格模式同时适用于函数体和函数参数，但是函数执行时，先执行函数参数，然后再执行函数体；由此，有个不合理的地方：只有从函数体之中才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。虽然可以先解析函数体代码，再执行参数代码，但是这样无疑增加了复杂性，隐藏标准索性禁止了这种用法，只要参数使用了默认值，解构赋值或者扩展运算符，就不能显式指定严格模式。
```js
function foo(a,b=a) { // 报错
  'use strict';
  // code...
}

function foo({a,b}) { // 报错
  'use strict';
  // code
}

function foo(a,...b) { // 报错
  'use strict';
  // code
}
```
  - 解决方案：
    - 设定全局性的严格模式，这是合法的。
    - 把函数包在一个无参数的立即执行函数里面。
```js
'use strict';
function foo(a,...b) { 
  // code
}
```

  
```js
const foo = (function(a,...b) { 
  'use strict';
  return function (value = 23) {
    // code
    return value;
  }
})
```
## name属性
- 函数的name属性返回该函数的函数名。
  - 如果将一个匿名函数赋值给一个变量，ES5会返回一个空字符串，ES6会返回实际的函数名。
  - 将一个具名函数赋值给一个变量，ES5，ES6都会返回具名函数原本的名字。
  - Function构造函数返回的函数实例，name属性的值为anonymous.
  - bind返回的函数，name属性值会加上bound前缀。
## 箭头函数
### 基本用法
- 允许使用【=>】定义函数
  - 箭头函数不需要参数或者需要多个参数，就使用圆括号代表参数部分。
  - 箭头函数的代码块部分多于一条语句，就要使用大括号将其括起来，并使用return语句返回。
  - 由于大括号被解释为代码块，如果箭头函数直接返回一个对象，必须在对象外面加上括号。
  - 箭头函数可以与变量结构结合使用。
- 箭头函数的用处之一就是简化回调函数。

### 注意事项
- 函数体内的this对象就是定义时所在的对象，而不是使用时所在的对象。
  - 箭头函数可以让this指向固定化，这种特性有利于封装回调函数。
  - this指向固定化是因为箭头函数没有自己的this，导致内部的this就是外层代码块耳朵this。正是因为没有this，所以不能用作构造函数。
- 不可以当作构造函数，即不可以使用new命令，否则会抛出一个错误。
- 不可以使用arguments对象，该对象在函数体内不存在，如果要用，可以用rest参数代替。
- 不可以使用yield命令，因此箭头函数不能用作Generator函数。
- 箭头函数没有自己的this，所以不能用call(),apply(),bind()这些方法去改变this的指向。

### 嵌套的箭头函数
- 箭头函数内部可以再使用箭头函数。
- 部署管道机制，即前一个函数的输出是后一个函数的输入。
- 方便的改写λ演算。
## 绑定this
- 箭头函数可以绑定this对象，大大减少了显示绑定this对象的写法（call(),apply(),bind()）
- 箭头函数并非适用于所有场合，所以ES7提出函数绑定运算符，用于取代call(),bind(),apply()调用。
  - 函数绑定运算符是并排的双冒号（::），双冒号左边是一个对象，右边是一个函数。该函数会自动将左边的对象作为上下文环境，即this对象，绑定到右边的函数上。
```js
    foo::bar ==> bar.bind(foo);
    foo::bar(...arguments) ==> bar.apply(foo,arguments);
    const hasOwnProperty = Object.prototype.hasOwnProperty;
    function hasOwn(obj,key) {
      return obj::hasOwnProperty(key);
    }
```
  - 如果双冒号左边为空，右边是一个对象方法，则等于将该方法绑定在该对象上。
```js
    var method = obj::obj.foo ==> ::obj.foo;
    let log = ::console.log ==> var log = console.log.bind(console);
```
  - 双冒号运算符返回的是原对象，因此可以采用链式写法。
```js
    let {find, html} = jake;
    document.querySelectorAll("div.myClass")::find("p")::html("hahaha");
```
## 尾调用优化
### 尾调用定义
- 尾调用：是函数式编程的一个重要概念，指某个函数的最后一步调用另一个函数。
  - 不一定出现在函数尾部，只要是最后一步操作即可。
### 尾调用优化
- 函数调用会在内存形成一个“调用记录”，又称调用帧，保存调用位置和内部变量等信息。如果在函数A内部调用函数B，在A的调用帧上方会形成一个B的调用帧；等到B运行结束，会返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那么就还有一个C的调用帧，以此类推。所有的调用帧就会形成一个调用栈。
- 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置，内部变量等信息都不会用到，直接用内层函数的调用帧取代外层函数的即可。
- 尾调用优化：只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时调用帧只有一项，这将大大节省内存，这就是尾调用优化的意义。
  - *注：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧。否则就无法进行尾调用优化。*
### 尾递归
- 递归
  - 函数调用自身
  - 耗费内存，需要同时保存成百上千个调用帧，很容易发生栈溢出错误
- 尾递归
  - 尾调用自身
  - 只存在一个调用帧，永远不会发生栈溢出错误

```js
function factorial(n) { // 递归
  if (n === 1) return 1;
  return n * factorial(n - 1); 
}
factorial(5);

function factorial (n, total) { // 尾递归
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5, 1);
```

```js
```

### 递归函数的改写

- 尾递归的实现往往需要改写递归函数，确保最后一步只调用自身，做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。
- 在尾递归函数之外再提供一个正常形式的函数。
```js
  function tailFactorial(n,total) {
    if (n === 1) return total;
    return tailFactorial(n-1, n * total);
  }

  function factorial(n) {
    return tailFactorial(n,1);
  }

  factorial(5);
```
  - 函数柯里化：将多参数函数转换成单参数的形式

```js
  function currying(fn,n) {
    return function (m) {
      return fn.call(this,m,n);
    };
  }

  function tailFactorial(n,total) {
    if(n===1) return total;
    return tailFactorial(n-1,n * total);
  }

  const factorial = currying(tailFactorial,1);

  factorial(5);
```
- 采用ES6的函数默认值
```js
  function factorial (n,total=1) {
    if (n === 1) return total;
    return factorial(n-1, n * total);
  }

  factorial(5);
```
- 递归的本质：
  - 是一种循环操作，纯粹的函数编程语言没有循环操作命令，所有循环都用递归实现，这就是为什么尾递归对这些语言及其重要
  - 循环可以用递归代替，而一旦使用递归，就最好使用尾递归

### 严格模式

- 尾调用优化只在严格模式下开启，正常模式下是无效的
  - 正常模式下函数内部有两个变量，可以跟踪函数的调用栈
  - func.arguments: 返回调用时函数的参数
  - func.caller: 返回调用当前函数的那个函数
- 尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。

```js
  function restricted() {
    'use strict';
    restricted.caller;
    restricted.arguments;
  }

  restricted();
```

### 尾递归优化的实现

- 尾递归需要优化，是因为调用栈太多造成移除，那么只需要减少调用，就不会发生溢出。
- 使用循环替换递归，就可以减少调用栈
```js
  function sum(x,y) {
    if (y > 0) {
      return sum(x+1,y-1);
    } else {
      return x;
    }
  }

  sum(1,1000000);
```
- 蹦床函数：可以将递归执行转为循环执行
  - 蹦床函数实现如下：接受函数f作为参数，只要f执行后返回一个函数，就继续执行
  - 这里是返回一个函数，然后执行该函数，而不是在函数里面调用函数，这样就可以避免了递归执行，从而消除了调用栈过大的问题
```js
  function trampoline(f) { // 蹦床函数的实现
    while(f && f instanceof Function) {
      f = f();
    }
    return f;
  }

  function sum(x,y) {
    if (y > 0) {
      return sum.bind(null,x+1,y-1);
    } else {
      return x;
    }
  }

  trampoline(sum(1,1000000));
```

- 真正的尾递归优化
  - tco 函数是尾递归优化的实现，奥妙之处在于状态变量active，默认情况下，这个变量是不被激活的，一旦进入尾递归优化的过程，它就被激活了；每一轮递归返回的都是undefined，所以就避免了递归执行，而accumulated数组存放每一轮sum执行的参数，总是有值的，就保证了accumulator函数内部的while循环总会执行，很巧妙的讲递归改成了循环，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。
```js
function tco(f) { 
  var value;
  var active = false;
  var accumulated = [];
  return function accumulator() {
    accumulated.push(arguments);
    if (!active) {
      active = true;while (accumulated.length) {
        value = f.apply(this,accumulated.shift());
      }
      active = false;
      return value;
    }
  };
}

var sum = tco (function (x,y) { 
  if(y > 0) {
    return sum(x + 1, y - 1)
  } else {
    return x;
  }
});

sum(1,1000000)
```

## 函数参数的尾逗号
- 允许函数的最后一个参数有尾逗号
- 此前，函数定义和调用时都不允许最后一个参数有尾逗号，改动时对于版本管理系统而言，就会显示添加逗号的那一行发生了改动，看上去显得冗余。
- 如此规定可以使得函数参数与数组和对象的尾逗号规则可以保持一致

# 章八、数组的扩展
## 扩展运算符
### 含义
- （...）扩展运算符，如同rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。
- 该运算符主要用于函数调用
- 该运算符可以将一个数组变为参数序列
- 扩展运算符可以与正常的函数参数结合使用
- 扩展运算符后面还可以防止表达式
- 扩展运算符后面如果是一个空数组，则不产生任何效果
### 替代数组的apply方法
- apply可用于将数组各项添加到另一个数组（MDN举的例子）
```js
  var array = ['a', 'b', 'c'];
  var elments = [1,2,3];
  array.push.apply(array, elments);
  console.log(array);
```
- 扩展运算符替换apply
```js
  var array = ['a', 'b', 'c'];
  var elments = [1,2,3];
  array.push(...elments);
  console.log(array);
```
- 使用apply和内置函数
  - 需要写循环以遍历各项数组的需求，可以使用apply完成以避免循环
```js
  // 找出数组中最大的数字
  var number = [1,2,35,4,7,6],
      max = -Infinity, min = +Infinity;
  for (let i of number) {
    if(max < i) {
      max = i;
    } else if(min > i) {
      min = i;
    }
  }
  console.log(min,max);

  max = Math.max(null, number);
  min = Math.min(null, number);
```
- 扩展运算符替换apply
```js
  max = Math.max(...number);
  min = Math.min(...number);
```
### 扩展运算符的应用
- 合并数组
```js
arr1.concat(arr2,arr3);
[...arr1,...arr2,arr3];
```
- 与解构赋值结合
  - 扩展运算符只能将其放在参数的最后一位，否则会报错
```js
a = list[0], rest = list[1];
[a,...rest] = list;

const [a,...b] = [1,2,3,4,5];
fist // 1;
b // [2,3,4,5];

const [a,...b] = [];
a // undefined
b // [];
```
- 函数的返回值
```js
var dateFileds = readDateFields(database);
var d = new Date(...dateFileds);
```
- 字符串
  - 将字符串转为真正的数组
  - 能够识别32位Unicode字符
```js
  [...'hello'];

  'x\uD83D\uDE80y'.length
  [...'x\uD83D\uDE80y'].length
```
- 实现Iterator接口的对象
  - 任何Iterator接口对象都可以用扩展运算符转为真正的数组
  - 类数组对象没有部署Iterator接口可以使用Array.from()转为真正的数组。
```js
let arr = ['a','b','d','dc']

let arrr = {
'0':'a',
'1':'ew',
'2':'er',
length: 3
}

```
- Map和Set结构、Generator函数
  - 扩展运算符内部调用的是数据结构的迭代器接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符
```js
  let map = new Map([
    [1,'one'],
    [2,'two'],
    [3,'three'],
  ]);

  var go = function*(){
    yield 1;
    yield 2;
    yield 3;
  };

  [...go()];

```
## Array.from()
- 用于将两类对象转为真正的数组：类数组对象（array-like object），可遍历对象（iterable）对象（如set和map）
  - 常见的类数组对象：DOM操作返回的NodeList集合；arguments对象
    - 类数组对象的本质特征：必须有length属性，任何有length属性的对象，都可以通过Array.from方法转为数组（只有length的类数组对象无法转换）可使用Array.prototype.slice方法替代。
- Array.from可接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。
- 如果map函数里用到了this关键字，还可以传入Array.from第三个参数，用来绑定this。
- Array.from()可以将各种值转为真正的数组，并且提供map功能，这十九意味着，只要有一个原始的数据结构，就可以先对它的值进行处理，然后转成规范的数据结构、进而可以使用数量众多的数组方法。
- Array.from的应用是，将字符串转为数组，然后返回字符串的长度，能正确解析32位Unicode的字符，可避免JavaScript错误解析字符串的长度。
```js
  let arrr = {
    '0':'a',
    '1':'ew',
    '2':'er',
    length: 3
  }

  var arr1 = [].slice.call(arrr);

  let arr2 = Array.from(arrr);
```

## Array.of()
- 作用：用于将一组值转换为数组
- 弥补数组的构造函数Array()的不足。
  - Array参数个数不同会导致其行为有差异，只有当参数不少于2个时，Array()才会返回由参数组成的新数组。参数只有一个时，十九是指定数组的长度。
  - Array.of可以用来替代Array()或者new Array(),并且不存在由于参数不同而导致的重载，其行为非常统一。
```js
  Array()
  Array.of()
  Array(3)
  Array.of(3)
  Array(3,11,6)
  Array.of(3,11,6)
  Array(undefined)
  Array.of(undefined)
```
- 模拟实现Array.of
## 数组实例的copyWithin()
- copyWithin会在当前数组内部将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。
- Array.prototype.copyWithin(target,start=0,end=this.length)
  - target: 必选，从该位置开始替换数据
  - start：可选，从该位置开始读取数据，默认为0，传入为负数表示倒数
  - end：可选，到该位置停止读取数据，默认等于数组长度，如果为负数，表示倒数。
  - 参数都是数值，如果不是，会自动转为数值。
## 数组实例的find()和findIndex()
- find
  - 用于找出第一个符合条件的数组成员，其参数是一个回调函数，所有数组成员依次执行返回该回调函数，直到找出第一个返回值为true的成员，然后返回该成员，如果没有符合条件的成员，返回undefined
- findIndex
  - 用于找出第一个符合条件的数组成员，其参数是一个回调函数，所有数组成员依次执行返回该回调函数，直到找出第一个返回值为true的成员，然后返回该成员的位置，如果没有符合条件的成员，返回-1
- find和findIndex可以接受第二个参数，用来绑定回调函数的this对象。
- find和findIndex都可以发现NaN，弥补了数组的IndexOf方法的不足
  - indexOf内部实现是借助===，findIndex方法借助的是Object.is方法，可是识别NaN
## 数组实例的fill()
- fill()用给定值填充一个数组
  - 用于空数组的初始化非常方便，数组中已有的元素会被全部抹去
  - fill()可接受第二个和第三个参数，用于指定填充的起始位置和结束位置
## 数组实例的entries(),keys(),values()
- 用于遍历数组
- 遍历方式
  - for...of循环遍历
  - 遍历器对象的next方法遍历
```js
  let leter = ['am','bb','cc']
  let values = leter.values()
  values.next().value
  values.next().value
  values.next().value
```
- 区别
  - keys():对键名遍历
  - values():对键值遍历
  - entries():对键值对遍历
## 数组实例的includes()
- 返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似
- 该方法的第二个参数表示搜索的起始位置，默认为0，如果第二个参数为负数，则表示倒数的位置；如果这时它大于数组的长度，则会重置为从0开始。
- indexOf
  - 不够语义化，其含义是找到参数值的第一个出现位置，所以要比较是否不等于-1，表达起来不够直观
  - 其内部严格使用相等运算符===进行判断，会导致对NaN的误判
- Map和Set数据结构有一个has方法，需要注意与includes区分
  - Map结构的has方法是用来查找键名的，如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target,propertyKey)
  - Set结构的has方法是用来查找键值的，如Set.prototype.has(value)、WeakSet.prototype.has(value)
## 数组的空位
- 数组的空位指数组的某一个位置没有任何值
  - *注：空位不是undefined，一个位置的值等于undefined依然是有值的，空位是没有任何值的，in运算符可以说明这一点*
  ```js
  0 in [undefined,undefined,undefined]
  0 in [,,,]
  ```
- ES5对空位的处理不一致，大多数情况下会忽略空位
  - forEach、filter、every、some都会跳过空位
  - map()会跳过空位，但是会保留这个值
  - join()和toString()会将空位视为undefined,而undefined和null都会被处理成空字符串
- ES6则是明确将空位转为undefined
  - Array.from(),扩展运算符(...),entries(),keys(),values(),find(),findIndex()会将空位处理成undefined
  - copyWithin():会连空位一起复制
  - fill()会将空位视为正常的数组位置
  - for...of遍历空位
- 空位的处理规则不统一，所以建议避免出现空位

# 章九 对象的扩展

## 属性的见解表示法

- 允许直接写入变量和函数作为对象的属性和方法
  - ES6允许在对象中只写属性名，不写属性值，这时属性值等于属性名所代表的变量
  - 方法可简写
  - 如果某个方法的值是一个Generator函数，则其前面需要加上星号

## 属性名表达式
- 定义对象的属性有两种方法
  - 直接用标识符作为属性名
  - 用表达式作为属性名，要将表达式放在方括号内
```js
obj.foo = true;
obj['a'+'b'] = false;
```
- 如果使用字面量方式定义对象（使用大括号），ES5中不能使用表达式，而只能用标识符定义属性
```js
  var obg = {
    foo: true,
    abc: 124
  }
```
- ES6允许字面量定义对象时使用表达式作为对象的属性名,即把表达式放在方括号内
```js
let propKey = 'foo';
let obj = {
  [propKey]: true,
  ['a'+'bc']:123
}
```
- 表达式还可以用于定义方法名
```js
let obj = {
  ['he'+'llo']:() {}
}

obj.hello();
```
- *注：属性名表达式和简介表示法不能同时使用*
- *属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]*
  - keyA和keyB得到的都是[object Object],所以keyB会覆盖keyA,最后myObj只有一个属性
```js
  const keyA = {a:1}
  const keyB = {b:2}
  const myObj = {
    [keyA]: 'valueA',
    [keyB]: 'value2'
  }

  myObj // {[object Object]: "value2"}
/* [object Object]: "value2"
__proto__: Object */
```
## 方法的name属性

## Object.is()

## Object.assign()

### 基本用法

### 注意点

### 常见用途

## 属性的可枚举性

## 属性的遍历

## __proto__属性、Object.setPrototypeOf()、Object.getPrototypeOf()

### __proto__属性

### Object.setPrototypeOf()

### Object.getPrototypeOf()

## Object.keys(),Object.values(),Object.entries()

### Object.keys()

### Object.values()

### Object.entries()

## 对象的扩展运算符

## Object.GetOwnPropertyDescriptors()

## Null传导运算符

