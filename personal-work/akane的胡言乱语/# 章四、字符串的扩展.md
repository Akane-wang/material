# 章四、字符串的扩展
## 字符的Unicode表示法
- JavaScript允许用\uxxxx形式表示码点在\u0000~\uFFFF之间的字符，超出这个范围则要使用两个双字节的形式表达，如\uD842\uDFB7
  - 这么使用是因为JavaScript会将超过0xFFFF的数值（如\u20BB7理解为\u20BB+7）,而\u20BB是不可打印字符，所以只会显示空格后面跟一个7。
- 所以ES6为解决这个问题，实现了将码点放入大括号，就能正确显示字符。
  - \u20BB7 写为 \u{20BB7}即可正确显示字符。
  - 且大括号表示法与四字节的UTF-16编码是完全等价的。 

## codePointAt()
- javascript内部字符以UTF-16的格式储存，每个字符固定为2个字节。对于需要4个字节储存的字符，JavaScript会认为它们是两个字符。
- 有四个字节的字符:
  - JavaScript会认为它的长度为2；
  - charAt(index)无法读取整个字符: // index 介于 0到s.length-1之间
  - charCodeAt()只能分别返回前两个字节和后两个字节的值
  - Es6提供codePointAt()可以正确处理四字节的字符，并返回一个字符的码点。
    - str.codePointAt(0)返回正常码点；如果是两字节字符，返回的码点和charCodeAt(0)一样
    - codePointAt()返回的码点是十进制值，要转为16进制，可通过toString(): str.codePointAt().toString(16);
    - str.codePointAt(1)返回四字节码点的后两个字节的码点;
    - for ... of循环可以正确识别32位的UTF-16字符
```js
var s = "𠮷a";
for (let item of s) {
    console.log(item.codePointAt(0).toString(16));
}
``` 

## String.fromCodePoint()
- 用于从码点返回对应字符：
  - String.fromCharCode(): 不能识别32位UTF-16字符（Unicode编号大于0xFFFF）。识别大于0xFFFF的字符将会发生溢出，会舍弃高位后返回舍弃高位的字符。
  - String.fromCodePoint(): 可识别大于0xFFFF的字符。
    - String.fromCodePoint()有多个参数，将会被合并成一个字符串返回：
        ```js
        String.fromCodePoint(0x78,0x1f680,0x79) === 'x\uD83D\uDE80y'  // true
        ```
*注意：fromCodePoint方法定义在String对象上，codePointAt方法定义在字符串的实例对象上*

## 字符串的遍历器接口
- ES6为字符串添加了遍历器接口，使得字符串可以由for...of循环遍历。
- 优点：该遍历器可以识别大于0XFFFF的码点，而传统的for循环无法识别这样的码点。

## repeat
- 返回一个新的字符串，表示将原字符串重复n次
- 数值：
  - 小数：取整，2.3 = 2；0.1 = 0；
  - 负数：报错
  - 无穷大：报错
  - 正整数：正常重复
- 字符串(先转换再取值)
  - 无法转换为数字的字符串'a'：先转换，转换为NaN
  - 字符串和数字的结合：'3a'：转换为NaN
  - 可转为数字的字符串：'3'：转为3，重复三次
- 特殊值：
  - NaN：等同于0

## 长度补全功能padStart(),padEnd()
- 字符串不够指定长度，会自动补全
- padStart(minlen,str):头部补全
- padEnd(minlen,str):尾部补全
- 用法
  - newStr = sourceStr.padStart(minlen,str?); // (str/' '重复到minlen减去sourceStr剩下的长度)sourceStr
  - newStr = sourceStr.padEnd(minlen,str?); // sourceStr(str/' '重复到minlen减去sourceStr剩下的长度)
- 参数
  - minlen: 字符串最小长度
  - str: 用以补全的字符串
- strlen > minlen: 返回原字符串
- strlen < minlen: 补全，如果str+sourceStr > minlen,截取掉str中的一部分
- str被省略：用空格补全
- 用途：
  - 为数值补全指定位数
  - 提示字符串格式

# 模板字符串
- 增强版字符串，用反引号标识
  - 当做普通字符串使用;
```js
`In the earth`;
```
  - 用于定义多行字符串;所有的空格和缩进都会被保留在输出中；
```js
`in javascript this is 
    not legal`
```
  - 如果不想要，可以使用trim()消除
```js
`   in javascript this is 
    not legal
`.trim()
```
  - 在字符串中嵌套变量；变量写在${}中
    - 大括号可以写入任意JavaScript表达式；
      - 可以进行运算；
      - 引用对象属性
      - 调用函数
    - 大括号的值不是字符串时，将按照一般的规则转为字符串（如大括号中是一个对象，将默认调用对象的toString()方法）
    - 变量没有声明将会报错
    - 大括号内是一个字符串，将会报错
    - 模板字符串还能嵌套
    - 模板字符串可引用模板字符串本身
```js
let hill = 'hill'
`hello,${hill}`
```
  - 在模板中使用反引号用斜杠转义
```js
`hello,${hill}`
`\`hello,\`,hello`
```

## 模板编译

```js
var template = `
    <ul>
        <% for(let item of data.supplies) {%>
            <li>
                <%= item %>
            </li>
        <%}%>
    </ul>
`
function compile(template) {
    var evalExpr = /<%=(.+?)%>/g;
    var expr = /<%([\s\S+?])%>/g;
    template = template.replace(evalExpr,'`); \n echo($1); \n echo(`').replace(expr,'`); \n $1 \n echo(`');

    template = 'echo(`'+ template + '`);';
    var script = `fnction parse(data){
        var output = "";
        function echo(html) {
            output += html;
        }
        ${ template }
        return output;
    }`;
    return script;
}

var parse = eval(compile(template));
div.innerHTML = parse({supplies: ["broom", "nop","cleaner"]});

```

## 标签模板
- 紧跟在一个函数名后面，该函数被调用来处理这个模板字符串，即标签模板功能。
- 标签模板其实不是模板，而是函数调用的一种特殊形式，标签指的是函数，紧跟在后面的模板字符串就是它的参数。
- 模板字符中有变量，则要将模板字符串先处理成多个参数，再调用函数。
  - tag函数的第一个参数是数组，该数组的成员是模板字符串中那些没有变量替换的部分。
    - 由此可知，变量替换只发生在第一个和第二个成员，第二个和第三个成员的成员之间，以此类推。
  - tag的其他参数都是模板字符串各个变量被替换后的值。
```js
    var a = 5,b=6;
    tag`Hello ${a+b} world ${a*b}`;

    function tag(strArr, ...values) {
        console.log(strArr);
        console.log(...values);
    }
```
- 作用：
  - 过滤HTML字符串，防止用户输入恶意内容

```js
    // var message = SaferHTML `<p>${sender} has sent you a message</p>`;
    function SaferHTML(templateData) {
        var s = templateData[0];
        for(let i = 0; i < arguments.length; i++) {
            var arg = String(arguments[i]);
            s+=arg.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");

            s+=templateData[i];
        }
        return s;
    }

    var sender = '<script>alert("abc")</script>';
    var message = SaferHTML`<p>${sender},Helloween</p>`
```
  - 多语言转换（国际化处理）

```js
i18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}`
```
  - 用标签模板在JavaScript中嵌入其他语言。
```js
    jsx`
        <div>
            <input ref="input"
            onChange = '${tshi.handleChange}'
            defaultValue = '${this.state.value}' />
            ${this.state.value}
        </div>
    `
```

## String.raw()
- 用来充当模板字符串的处理函数，返回一个反斜线都被转移的字符串，对应于替换变量后的模板字符串
- 作为正常的函数使用，第一个参数应该具有raw属性的对象，且raw属性的值应该是一个数组
## 模板字符串的限制
- 模板字符串会将标签模板解析中的一些字符转义，比如遇上\u00FF这种类型，会当做Unicode转义；
- 为了解决这个问题，提案提出，放松对标签模板里面的字符串转义的限制，如果遇到不合法的字符串转义，就返回undefined，而非报错，并且从raw属性上可以得到原始字符串。
- 这种对字符串的转义放松只有标签模板解析字符串时生效，非标签模板的场合依然会报错。

# 正则的扩展
## RegExp构造函数
- 参数是字符串，第二个参数是表示正则表达式的修饰符（flag）
    ```js
    var regex = new RegExp('xyz','i'); // var regex = /xyz/i
    ```
- 参数是一个正则表达式，会返回一个原因正则表达式的拷贝
    ```js
        var regex = new RegExp(/xyz/i); // var regex = /xyz/i
    ```
- ES5:
  - 不允许此时使用第二个参数添加修饰符
    ```js
        var regex = new RegExp(/xyz/,'i'); // Uncaught TypeError: cannot supply flags
    ```
- ES6：
  - 可以使用第二个参数指定修饰符，并且返回的表达式会忽略原有正则表达式的修饰符，只使用新指定的修饰符
    ```js
    var regex = new RegExp('/xyz/ig,'i'); regex.flags: "i"
    ```

## 字符串的正则方法
- 方法
  - String.prototype.match;
  - String.prototype.replace;
  - String.prototype.search;
  - String.prototype.split;
- ES6使这四个方法在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法都定义在RegExp对象上

## U修饰符
- ES6对正则表达式增加了u修饰符，含义为Unicode模式，用于正确处理大于\uFFFF的Unicode字符，即可以正确处理4个字节的UTF-16编码。
 - 增加u修饰符后，ES6会识别大于\uFFFF的Unicode字符为一个字符；不增加u，JavaScript就会将4字节字符识别为2个字节字符。
```js
 /^\uD83D/u.test('\uD83D\uDC2A'); // false;
 /^\uD83D/.test('\uD83D\uDC2A'); // true;
```

- 点字符
  - 点(.)字符在正则表达式中的含义是除换行符以外的任意单个字符。
  - 码点大于0uFFFF的字符，点字符不能识别，需要加u修饰符。

- Unicode字符表示法
  - ES6新增大括号表示Unicode字符的表示法。这种表示法需要在正则表发誓中必须增加u修饰符才能识别当中的大括号。否则会被解读为量词。
  
- 量词
  - 使用u修饰符后，所有两次都会正确识别码点大于0xFFFF的Unicode字符。

- 预定义模式
  - u修饰符也影响到预定义模式是否正确识别码点大于0xFFFF的Unicode字符。

- i修饰符
  - 有些Unicode字符的编码不同，但是字形很相近，如\u004B和\u212A都是大写的K。不加u修饰符就无法识别非规范的K字符。

## y修饰符
- 粘连（sticky）修饰符
- y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于g修饰符只要剩余位置从存在匹配就行，而y修饰符会保证匹配彼此从剩余的第一个位置开始，这也就是粘连的含义。
- lastIndex属性指定每次搜索的开始位置
  - g修饰符从这个位置开始向后搜索，直到发现匹配为止
  - y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配
- y修饰符的设计本意就是让头部匹配的标志(^)在全局匹配都有效
- split
  - 在split中使用y修饰符，原字符串必须以分隔符开头
- match
  - 单独一个y修饰符对match方法只能返回第一个匹配，必须与g修饰符连用才能返回所有匹配
- 应用
  - 从字符串中提取token(词元)，y修饰符确保了匹配之间不会有漏掉的字符。

## sticky属性
- 与y修饰符相匹配，表示是否设置了y修饰符
```js
var r = /hello\d/y
r.sticky
```
## flags属性
- 返回正则表达式的修饰符
```js
/abc/ig.source // abc
/abc/ig.flags // ig
```

## s修饰符：doAll模式
- 点（.）是一个特殊的字符，代表任意的单个字符，除行终止符外
  - “行终止符”
    - U+000A 换行符(\n)
    - U+000D 回车符(\r)
    - U+2028 行分隔符
    - U+2029 段分隔符
  ```js
  /foo.bar/.('foo\nbar') // false, . 匹配不了\n
  ```
- 为解决匹配不了“行终止符”的问题，有两种方法
  - 变通写法：[^]——缺点：不太符合直觉
    ```js
    /foo[^]bar/.test('foo\nbar')
    ```
  - 引入\s修饰符，使得[.]可以匹配任意单个字符
    ```js
        /foo.bar/s.test('foo\nbar') // true
    ```
    - 这称为doAll模式，即点（dot）代表一切字符，所以，正则表达式还引入了一个doAll属性，返回一个布尔值，表示该正则表达式是否处在doAll模式下。
    ```js
        const re = /foo.bar/s
        re.doAll // true
    ```
    - \s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，“.”匹配所有字符，^和$匹配每一行的行首和行尾

## 后行断言
- 先行断言：x只有在y前面才匹配，必须写成/x(?=y)/的形式
- 先行否定断言：x只有不在y前面才匹配，必须写成/x(?!y)/的形式
- 后行断言：x只有在y后面才匹配，必须写成/(?<=y)x/的形式；需要先匹配x，再回到左边匹配y的部分，先右后左
  - 后行断言的反斜杠引用也与通常的循序相反，必须放在对应括号之前；因为后行断言是先从左到右扫描，发现匹配以后再回过头从右到左完成反斜杠引用
- 后行否定断言：x只有不在y后面才匹配，必须写成/(?<!y)x/的形式

## Unicode属性类
- 提案：引入了一种新的类的写法：\p{...}和\P{...},允许正则表达式匹配符合Unicode某种属性的所有字符。
- Unicode属性类指定属性名和属性值
- 对于某些属性，可以只写属性名
- \P{...}与\p{...}是反向匹配，即匹配不满足条件的字符
- *注：这两种类只对Unicode有效，所以使用的时候一定要加上u修饰符，否则会报错*

## 具名组匹配
- 正则表达式使用圆括号进行组匹配
const Re_Date = /(\d{4})-(\d{2})-(\d{2})/;
- 问题：每一组的匹配含义不容易看出来，而且只能用数字序号引用，要是组的顺序变了，引用的时候就必须修改序号
- 具名组匹配
  - 允许为每一个组匹配指定的名字，便于阅读代码和引用
  ```js
  const Re_Date = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
  ```
  - 使用方式： 在模式的头部添加问号+尖括号+组名(?<year>),就可以在exec方法返回的结果的groups属性上引用该组名。数字序号依然有效。
  - 具名组匹配等于为每一组匹配加上了ID，这样便于描述匹配的目的，如果组的顺序变了，也不用改变匹配后的处理代码。
  - 如果没有匹配到值，具名组匹配的属性值就是undefined，但是键名是始终存在的。

- 解构赋值和替换
  - 有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值
  - 字符串替换时，使用$<组名>引用具名组
  - 具名组匹配在原来的基础上新增了最后一个函数参数：具名组构成的一个对象，函数内部可以直接对这个对象进行解构赋值

- 引用
  - 如果要在正则表达式内部引用某个“具名组匹配”，可以使用\k<组名>的写法，也可以使用顺序（\number）